{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-duckdb","text":"<p>Prefect intergrations with DuckDB.</p>"},{"location":"#resources","title":"Resources","text":"<p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-duckdb</code> with <code>pip</code>:</p> <pre><code>pip install prefect-duckdb\n</code></pre> <p>Requires an installation of Python 3.8+.</p> <p>We recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.</p> <p>These tasks are designed to work with Prefect 2.0. For more information about how to use Prefect, please refer to the Prefect documentation.</p>"},{"location":"#feedback","title":"Feedback","text":"<p>If you encounter any bugs while using <code>prefect-duckdb</code>, feel free to open an issue in the prefect-duckdb repository.</p> <p>If you have any questions or issues while using <code>prefect-duckdb</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-duckdb</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-duckdb</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code>pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <pre><code>pre-commit install\n</code></pre></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request</li> </ol>"},{"location":"blocks_catalog/","title":"Blocks Catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-duckdb</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud, first install the required packages, then <pre><code>prefect block register -m prefect_duckdb\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"blocks_catalog/#database-module","title":"Database Module","text":"<p>DuckDBConnector</p> <p>Perform data operations against a DuckDb database.</p> <p>To load the DuckDBConnector: <pre><code>from prefect import flow\nfrom prefect_duckdb.database import DuckDBConnector\n\n@flow\ndef my_flow():\n    my_block = DuckDBConnector.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Database Module under Examples Catalog.</p>"},{"location":"connector/","title":"Connector","text":""},{"location":"connector/#prefect_duckdb.database","title":"<code>prefect_duckdb.database</code>","text":"<p>Module for querying against DuckDB databases.</p>"},{"location":"connector/#prefect_duckdb.database-classes","title":"Classes","text":""},{"location":"connector/#prefect_duckdb.database.DuckDBConnector","title":"<code>DuckDBConnector</code>","text":"<p>             Bases: <code>DatabaseBlock</code></p> <p>A block for connecting to a DuckDB database.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <p>DuckDBConfig block to be used when creating connection.</p> required <code>database</code> <p>The name of the default database to use.</p> required <code>read_only</code> <p>Whether the connection should be read-only.</p> required <p>Examples:</p> <p>Load stored DuckDB connector as a context manager: <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nduckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\"):\n</code></pre></p> <p>Insert data into database and fetch results. <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = conn.fetch_all(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Space\"}\n    )\n    print(results)\n</code></pre></p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>class DuckDBConnector(DatabaseBlock):\n    \"\"\"\n    A block for connecting to a DuckDB database.\n\n    Args:\n        configuration: DuckDBConfig block to be used when creating connection.\n        database: The name of the default database to use.\n        read_only: Whether the connection should be read-only.\n\n    Examples:\n        Load stored DuckDB connector as a context manager:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\"):\n        ```\n\n        Insert data into database and fetch results.\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n            )\n            conn.execute_many(\n                \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n                parameters=[\n                    {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n                    {\"name\": \"Unknown\", \"address\": \"Space\"},\n                    {\"name\": \"Me\", \"address\": \"Myway 88\"},\n                ],\n            )\n            results = conn.fetch_all(\n                \"SELECT * FROM customers WHERE address = %(address)s\",\n                parameters={\"address\": \"Space\"}\n            )\n            print(results)\n        ```\n    \"\"\"\n\n    _block_type_name = \"DuckDB Connector\"\n    _logo_url = \"https://duckdb.org/images/logo-dl/DuckDB_Logo.png\"  # noqa\n    _documentation_url = \"https://placeholder.com\"  # noqa\n    _description = \"Perform data operations against a DuckDb database.\"\n\n    configuration: Optional[dict] = Field(\n        default=None, description=\"Configuration to be used when creating connection.\"\n    )\n    database: str = Field(\n        default=\":memory:\", description=\"The name of the default database to use.\"\n    )\n    read_only: bool = Field(\n        default=False,\n        description=\"Whether the connection should be read-only.\",\n    )\n    _connection: Optional[DuckDBPyConnection] = None\n    _debug: bool = False\n\n    def get_connection(\n        self, read_only: Optional[bool] = None, config: Optional[dict] = None\n    ) -&gt; DuckDBPyConnection:\n        \"\"\"\n        Returns a  DuckDB connection, if `mother_ducktoken` is found in enviroment\n        or config, it will be passed in the connection.\n\n        Args:\n            read_only: Whether the connection should be read-only.\n            config: Configuration to be used when creating connection.\n\n        Returns:\n            A `DuckDBPyConnection` object.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\n            with duckdb_connector as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING);\")\n                ...\n            ```\n        \"\"\"\n        if self._connection is not None:\n            return self._connection\n\n        config = config or self.configuration or {}\n        read_only = read_only or self.read_only\n\n        if os.environ.get(\"motherduck_token\") and \"motherduck_token\" not in config:\n            config[\"motherduck_token\"] = os.environ.get(\"motherduck_token\")\n\n        connection = duckdb.connect(\n            database=self.database,\n            read_only=read_only,\n            config=config,\n        )\n\n        self._connection = connection\n        self.logger.info(f\"Started a new connection to {self.database}.\")\n        return connection\n\n    @sync_compatible\n    async def execute(\n        self,\n        operation: str,\n        parameters: Optional[Iterable[Any]] = [],\n        multiple_parameter_sets: bool = False,\n        debug: Optional[bool] = False,\n    ) -&gt; DuckDBPyConnection:\n        \"\"\"\n        Execute the given SQL query, optionally using prepared statements\n        with parameters set.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n            multiple_parameter_sets: Whether to execute the operation multiple times.\n            debug: Whether to run the operation in debug mode.\n                   Sends the query plan to the logger.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\n                    \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n                )\n            ```\n        \"\"\"\n        self.get_connection()\n        cursor = self._connection.cursor()\n        if self._debug or debug:\n            await self.create_query_plan_markdown(operation, cursor, parameters)\n\n        cursor = await run_sync_in_worker_thread(\n            cursor.execute, operation, parameters, multiple_parameter_sets\n        )\n        self.logger.info(f\"Executed the operation, {operation!r}.\")\n        return cursor\n\n    @sync_compatible\n    async def sql(\n        self,\n        operation: str,\n        debug: Optional[bool] = False,\n    ) -&gt; DuckDBPyRelation:\n        \"\"\"\n        Execute the given SQL query, optionally using prepared statements\n        with parameters set.\n\n        Args:\n            operation: The SQL operation to execute.\n            debug: Whether to run the operation in debug mode.\n                   Sends the query plan to the logger.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.sql(\n                    \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n                )\n            ```\n        \"\"\"\n        self.get_connection()\n        cursor = self._connection.cursor()\n        if self._debug or debug:\n            await self.create_query_plan_markdown(operation=operation, cursor=cursor)\n        cursor = await run_sync_in_worker_thread(cursor.sql, operation)\n        self.logger.info(f\"Executed the operation, {operation!r}.\")\n        return cursor\n\n    @sync_compatible\n    async def execute_many(\n        self,\n        operation: str,\n        parameters: Iterable[Iterable[Any]] = [],\n        debug: Optional[bool] = False,\n    ) -&gt; DuckDBPyConnection:\n        \"\"\"\n        Execute the given prepared statement multiple times using the\n        list of parameter sets in parameters\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n            debug: Whether to run the operation in debug mode.\n                   Sends the query plan to the logger.\n\n        Examples:\n            ```python\n                from prefect_duckdb.database import DuckDBConnector\n\n                with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                    conn.execute_many(\n                        \"INSERT INTO test_table VALUES (?, ?)\",\n                        parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n                    )\n            ```\n        \"\"\"\n        cursor = self._connection.cursor()\n        if self._debug or debug:\n            await self.create_query_plan_markdown(operation, cursor, parameters)\n        await run_sync_in_worker_thread(cursor.executemany, operation, parameters)\n        self.logger.info(f\"Executed {len(parameters)} operations off {operation!r}.\")\n        return cursor\n\n    @sync_compatible\n    async def fetch_one(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n    ) -&gt; Tuple[Any]:\n        \"\"\"\n        Fetch a single result from the database.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n\n        Returns:\n            A tuple representing the result.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n                result = conn.fetch_one(\"SELECT * FROM test_table\")\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n            self.logger.debug(\"Preparing to fetch a row.\")\n            result = await run_sync_in_worker_thread(cursor.fetchone)\n            return result\n\n    @sync_compatible\n    async def fetch_many(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n        size: Optional[int] = 1,\n    ) -&gt; List[Tuple[Any]]:\n        \"\"\"\n        Fetch multiple results from the database.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n            size: The number of rows to fetch.\n\n        Returns:\n            A list of tuples representing the results.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute_many(\n                    \"INSERT INTO test_table VALUES (?, ?)\",\n                    parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n                )\n                result = conn.fetch_many(\"SELECT * FROM test_table\", size=2)\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n            size = size\n            self.logger.debug(f\"Preparing to fetch {size} rows.\")\n            result = await run_sync_in_worker_thread(cursor.fetchmany, size=size)\n            return result\n\n    @sync_compatible\n    async def fetch_all(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n    ) -&gt; List[Tuple[Any]]:\n        \"\"\"\n        Fetch all results from the database.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n\n        Returns:\n            A list of tuples representing the results.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n                result = conn.fetch_all(\"SELECT * FROM test_table\")\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n            self.logger.debug(\"Preparing to fetch all rows.\")\n            result = await run_sync_in_worker_thread(cursor.fetchall)\n            return result\n\n    @sync_compatible\n    async def fetch_numpy(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n    ) -&gt; dict:\n        \"\"\"\n        Fetch all results of the query from the database as a numpy array.\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n\n        Returns:\n            A dictionary representing a numpy array.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n                result = conn.fetch_numpy(\"SELECT * FROM test_table\")\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n            self.logger.debug(\"Preparing to fetch all rows.\")\n            result = await run_sync_in_worker_thread(cursor.fetchnumpy)\n            return result\n\n    @sync_compatible\n    async def fetch_df(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n        date_as_object: bool = False,\n    ) -&gt; pandas.DataFrame:\n        \"\"\"\n        Fetch all results of the query from the database as a dataframe.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n\n        Returns:\n            A pandas dataframe.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n                result = conn.fetch_df(\"SELECT * FROM test_table\")\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(\n                cursor.execute, operation, parameters, date_as_object\n            )\n            self.logger.debug(\"Preparing to fetch all rows.\")\n            result = await run_sync_in_worker_thread(cursor.df)\n            return result\n\n    @sync_compatible\n    async def fetch_arrow(\n        self,\n        operation: str,\n        parameters: Optional[Dict[str, Any]] = [],\n    ) -&gt; Any:\n        \"\"\"\n        Fetch all results of the query from the database as an Arrow table.\n\n        Args:\n            operation: The SQL operation to execute.\n            parameters: The parameters to pass to the operation.\n\n        Returns:\n            An Arrow table.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n                result = conn.fetch_arrow(\"SELECT * FROM test_table\")\n                print(result)\n            ```\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n            self.logger.debug(\"Preparing to fetch all rows.\")\n            result = await run_sync_in_worker_thread(cursor.arrow)\n            return result\n\n    @sync_compatible\n    async def create_function(\n        self,\n        name: str,\n        func: Callable,\n        parameters: Optional[Dict[str, Any]] = None,\n        return_type: Optional[str] = None,\n        side_effects: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        Create a function in the database.\n\n        Args:\n            name: string representing the unique name of the UDF within the catalog.\n            func: The Python function you wish to register as a UDF.\n            parameters: This parameter takes a list of column types used as input.\n            return_type: Scalar functions return one element per row.\n                         This parameter specifies the return type of the function.\n            side_effects: Whether the function has side effects.\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            await run_sync_in_worker_thread(\n                cursor.create_function,\n                name,\n                func,\n                parameters,\n                return_type,\n                side_effects=side_effects,\n            )\n            self.logger.info(f\"Created function {name!r}.\")\n\n    def create_secret(\n        self,\n        name: str,\n        secret_type: Literal[\"S3\", \"AZURE\"],\n        key_id: Optional[str] = None,\n        secret: Optional[str] = None,\n        region: Optional[str] = None,\n        scope: Optional[str] = None,\n    ):\n        \"\"\"Create a secret in DuckDB.\n\n        Args:\n            name: The name of the secret.\n            secret_type: The type of secret.\n            key_id: The key ID.\n            secret: The secret.\n            region: The region.\n            scope: The scope.\n\n        Examples:\n            ```python\n            from prefect_duckdb.database import DuckDBConnector\n            from prefect_aws import AwsCredentials\n\n            aws_credentials_block = AwsCredentials.load(\"BLOCK_NAME\")\n            connector = DuckDBConnector().load(\"BLOCK_NAME\")\n            connector.get_connection()\n            connector.create_secret(\n                name=\"test_secret\",\n                secret_type=\"S3\",\n                key_id=aws_credentials_block.access_key,\n                secret=aws_credentials_block.secret_access_key,\n                region=aws_credentials_block.region_name\n            )\n            connector.execute(\"SELECT count(*) FROM 's3://&lt;bucket&gt;/&lt;file&gt;';\")\n            ```\n        \"\"\"\n        if not self._connection:\n            self.get_connection()\n\n        args = []\n        if type(secret) == SecretStr:\n            secret = secret.get_secret_value()\n        if key_id:\n            args.append(f\"KEY_ID '{key_id}'\")\n        if secret:\n            args.append(f\"SECRET '{secret}'\")\n        if region:\n            args.append(f\"REGION '{region}'\")\n        if scope:\n            args.append(f\"SCOPE '{scope}'\")\n\n        argstring = \", \".join(args)\n        self._connection.execute(\n            f\"\"\"CREATE SECRET {name} ( TYPE {secret_type}, {argstring});\"\"\"\n        )\n\n    @sync_compatible\n    async def from_csv_auto(\n        self,\n        file_name: str,\n    ) -&gt; DuckDBPyRelation:\n        \"\"\"\n        Create a table from a CSV file.\n\n        Args:\n            file_name: The name of the CSV file.\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            return await run_sync_in_worker_thread(cursor.from_csv_auto, file_name)\n\n    @sync_compatible\n    async def from_df(\n        self,\n        df: pandas.DataFrame,\n        table_name: Optional[str] = None,\n    ) -&gt; DuckDBPyRelation:\n        \"\"\"\n        Create a table from a Pandas DataFrame.\n\n        Args:\n            df: The Pandas DataFrame.\n            table_name: The name of the table.\n        \"\"\"\n        cursor = self._connection.cursor()\n        table = await run_sync_in_worker_thread(cursor.from_df, df)\n        if table_name:\n            await run_sync_in_worker_thread(cursor.register, table_name, table)\n        return cursor\n\n    @sync_compatible\n    async def from_arrow(\n        self, arrow_object: pa.Table, table_name: Optional[str] = None\n    ) -&gt; DuckDBPyRelation:\n        \"\"\"\n        Create a table from an Arrow object.\n\n        Args:\n            arrow_object: The Arrow object.\n        \"\"\"\n        cursor = self._connection.cursor()\n        table = await run_sync_in_worker_thread(cursor.from_arrow, arrow_object)\n        if table_name:\n            await run_sync_in_worker_thread(cursor.register, table_name, table)\n        return cursor\n\n    @sync_compatible\n    async def from_parquet(\n        self,\n        file_name: str,\n    ) -&gt; DuckDBPyRelation:\n        \"\"\"\n        Create a table from a Parquet file.\n\n        Args:\n            file_name: The name of the Parquet file.\n        \"\"\"\n        with self._connection.cursor() as cursor:\n            return await run_sync_in_worker_thread(cursor.from_parquet, file_name)\n\n    def remove_function(self, name: str) -&gt; None:\n        \"\"\"\n        Remove a function from the database.\n\n        Args:\n            name: string representing the unique name of the UDF within the catalog.\n        \"\"\"\n        self._connection.remove_function(name)\n\n    def set_debug(self, debug: bool) -&gt; None:\n        \"\"\"\n        Set the debug mode of the connector.\n\n        Args:\n            debug: Whether to enable debug mode.\n        \"\"\"\n        self._debug = debug\n        self.logger.info(f\"Set debug mode to {debug}.\")\n\n    async def create_query_plan_markdown(\n        self,\n        operation: str,\n        cursor: DuckDBPyConnection,\n        parameters: Optional[list] = [],\n    ):\n        debug_operation = f\"\"\"EXPLAIN \\\n                            {operation}\"\"\"\n        plan = cursor.execute(debug_operation, parameters)\n        plan = plan.df()\n        plan = plan.rename(columns={\"explain_value\": \"Physical_Plan\"})[\n            \"Physical_Plan\"\n        ].to_markdown(index=False)\n\n        markdown = f\"\"\"\n```\n{plan}\n```\n\"\"\"\n        artifact_key = re.sub(\"[^A-Za-z0-9 ]+\", \"\", operation).lower().replace(\" \", \"-\")\n\n        self.logger.info(markdown)\n        async with get_client():\n            return await create_markdown_artifact(\n                key=artifact_key,\n                markdown=markdown,\n                description=\"The query plan for the operation.\",\n            )\n\n    def close(self):\n        \"\"\"\n        Closes connection and its cursors.\n        \"\"\"\n        if self._connection is None:\n            self.logger.info(\"There was no connection open to be closed.\")\n            return\n        self._connection.close()\n        self._connection = None\n        self.logger.info(\"Successfully closed the DuckDB connection.\")\n\n    def __enter__(self):\n        \"\"\"\n        Start a connection upon entry.\n        \"\"\"\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"\n        Closes connection and its cursors upon exit.\n        \"\"\"\n        self.close()\n\n    def __getstate__(self):\n        \"\"\"Allows block to be pickled and dumped.\"\"\"\n        data = self.__dict__.copy()\n        data.update({k: None for k in {\"_connection\"}})\n        return data\n\n    def __setstate__(self, data: dict):\n        \"\"\"Reset connection and cursors upon loading.\"\"\"\n        self.__dict__.update(data)\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector-functions","title":"Functions","text":""},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.__enter__","title":"<code>__enter__</code>","text":"<p>Start a connection upon entry.</p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def __enter__(self):\n    \"\"\"\n    Start a connection upon entry.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.__exit__","title":"<code>__exit__</code>","text":"<p>Closes connection and its cursors upon exit.</p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def __exit__(self, *args):\n    \"\"\"\n    Closes connection and its cursors upon exit.\n    \"\"\"\n    self.close()\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.__getstate__","title":"<code>__getstate__</code>","text":"<p>Allows block to be pickled and dumped.</p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Allows block to be pickled and dumped.\"\"\"\n    data = self.__dict__.copy()\n    data.update({k: None for k in {\"_connection\"}})\n    return data\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.__setstate__","title":"<code>__setstate__</code>","text":"<p>Reset connection and cursors upon loading.</p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def __setstate__(self, data: dict):\n    \"\"\"Reset connection and cursors upon loading.\"\"\"\n    self.__dict__.update(data)\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.close","title":"<code>close</code>","text":"<p>Closes connection and its cursors.</p> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def close(self):\n    \"\"\"\n    Closes connection and its cursors.\n    \"\"\"\n    if self._connection is None:\n        self.logger.info(\"There was no connection open to be closed.\")\n        return\n    self._connection.close()\n    self._connection = None\n    self.logger.info(\"Successfully closed the DuckDB connection.\")\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.create_function","title":"<code>create_function</code>  <code>async</code>","text":"<p>Create a function in the database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>string representing the unique name of the UDF within the catalog.</p> required <code>func</code> <code>Callable</code> <p>The Python function you wish to register as a UDF.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>This parameter takes a list of column types used as input.</p> <code>None</code> <code>return_type</code> <code>Optional[str]</code> <p>Scalar functions return one element per row.          This parameter specifies the return type of the function.</p> <code>None</code> <code>side_effects</code> <code>bool</code> <p>Whether the function has side effects.</p> <code>False</code> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def create_function(\n    self,\n    name: str,\n    func: Callable,\n    parameters: Optional[Dict[str, Any]] = None,\n    return_type: Optional[str] = None,\n    side_effects: bool = False,\n) -&gt; None:\n    \"\"\"\n    Create a function in the database.\n\n    Args:\n        name: string representing the unique name of the UDF within the catalog.\n        func: The Python function you wish to register as a UDF.\n        parameters: This parameter takes a list of column types used as input.\n        return_type: Scalar functions return one element per row.\n                     This parameter specifies the return type of the function.\n        side_effects: Whether the function has side effects.\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(\n            cursor.create_function,\n            name,\n            func,\n            parameters,\n            return_type,\n            side_effects=side_effects,\n        )\n        self.logger.info(f\"Created function {name!r}.\")\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.create_secret","title":"<code>create_secret</code>","text":"<p>Create a secret in DuckDB.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the secret.</p> required <code>secret_type</code> <code>Literal['S3', 'AZURE']</code> <p>The type of secret.</p> required <code>key_id</code> <code>Optional[str]</code> <p>The key ID.</p> <code>None</code> <code>secret</code> <code>Optional[str]</code> <p>The secret.</p> <code>None</code> <code>region</code> <code>Optional[str]</code> <p>The region.</p> <code>None</code> <code>scope</code> <code>Optional[str]</code> <p>The scope.</p> <code>None</code> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\nfrom prefect_aws import AwsCredentials\n\naws_credentials_block = AwsCredentials.load(\"BLOCK_NAME\")\nconnector = DuckDBConnector().load(\"BLOCK_NAME\")\nconnector.get_connection()\nconnector.create_secret(\n    name=\"test_secret\",\n    secret_type=\"S3\",\n    key_id=aws_credentials_block.access_key,\n    secret=aws_credentials_block.secret_access_key,\n    region=aws_credentials_block.region_name\n)\nconnector.execute(\"SELECT count(*) FROM 's3://&lt;bucket&gt;/&lt;file&gt;';\")\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def create_secret(\n    self,\n    name: str,\n    secret_type: Literal[\"S3\", \"AZURE\"],\n    key_id: Optional[str] = None,\n    secret: Optional[str] = None,\n    region: Optional[str] = None,\n    scope: Optional[str] = None,\n):\n    \"\"\"Create a secret in DuckDB.\n\n    Args:\n        name: The name of the secret.\n        secret_type: The type of secret.\n        key_id: The key ID.\n        secret: The secret.\n        region: The region.\n        scope: The scope.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n        from prefect_aws import AwsCredentials\n\n        aws_credentials_block = AwsCredentials.load(\"BLOCK_NAME\")\n        connector = DuckDBConnector().load(\"BLOCK_NAME\")\n        connector.get_connection()\n        connector.create_secret(\n            name=\"test_secret\",\n            secret_type=\"S3\",\n            key_id=aws_credentials_block.access_key,\n            secret=aws_credentials_block.secret_access_key,\n            region=aws_credentials_block.region_name\n        )\n        connector.execute(\"SELECT count(*) FROM 's3://&lt;bucket&gt;/&lt;file&gt;';\")\n        ```\n    \"\"\"\n    if not self._connection:\n        self.get_connection()\n\n    args = []\n    if type(secret) == SecretStr:\n        secret = secret.get_secret_value()\n    if key_id:\n        args.append(f\"KEY_ID '{key_id}'\")\n    if secret:\n        args.append(f\"SECRET '{secret}'\")\n    if region:\n        args.append(f\"REGION '{region}'\")\n    if scope:\n        args.append(f\"SCOPE '{scope}'\")\n\n    argstring = \", \".join(args)\n    self._connection.execute(\n        f\"\"\"CREATE SECRET {name} ( TYPE {secret_type}, {argstring});\"\"\"\n    )\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.execute","title":"<code>execute</code>  <code>async</code>","text":"<p>Execute the given SQL query, optionally using prepared statements with parameters set.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Iterable[Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <code>multiple_parameter_sets</code> <code>bool</code> <p>Whether to execute the operation multiple times.</p> <code>False</code> <code>debug</code> <code>Optional[bool]</code> <p>Whether to run the operation in debug mode.    Sends the query plan to the logger.</p> <code>False</code> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n    )\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def execute(\n    self,\n    operation: str,\n    parameters: Optional[Iterable[Any]] = [],\n    multiple_parameter_sets: bool = False,\n    debug: Optional[bool] = False,\n) -&gt; DuckDBPyConnection:\n    \"\"\"\n    Execute the given SQL query, optionally using prepared statements\n    with parameters set.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n        multiple_parameter_sets: Whether to execute the operation multiple times.\n        debug: Whether to run the operation in debug mode.\n               Sends the query plan to the logger.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\n                \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n            )\n        ```\n    \"\"\"\n    self.get_connection()\n    cursor = self._connection.cursor()\n    if self._debug or debug:\n        await self.create_query_plan_markdown(operation, cursor, parameters)\n\n    cursor = await run_sync_in_worker_thread(\n        cursor.execute, operation, parameters, multiple_parameter_sets\n    )\n    self.logger.info(f\"Executed the operation, {operation!r}.\")\n    return cursor\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.execute_many","title":"<code>execute_many</code>  <code>async</code>","text":"<p>Execute the given prepared statement multiple times using the list of parameter sets in parameters</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Iterable[Iterable[Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <code>debug</code> <code>Optional[bool]</code> <p>Whether to run the operation in debug mode.    Sends the query plan to the logger.</p> <code>False</code> <p>Examples:</p> <pre><code>    from prefect_duckdb.database import DuckDBConnector\n\n    with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n        conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n        conn.execute_many(\n            \"INSERT INTO test_table VALUES (?, ?)\",\n            parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n        )\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def execute_many(\n    self,\n    operation: str,\n    parameters: Iterable[Iterable[Any]] = [],\n    debug: Optional[bool] = False,\n) -&gt; DuckDBPyConnection:\n    \"\"\"\n    Execute the given prepared statement multiple times using the\n    list of parameter sets in parameters\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n        debug: Whether to run the operation in debug mode.\n               Sends the query plan to the logger.\n\n    Examples:\n        ```python\n            from prefect_duckdb.database import DuckDBConnector\n\n            with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n                conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n                conn.execute_many(\n                    \"INSERT INTO test_table VALUES (?, ?)\",\n                    parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n                )\n        ```\n    \"\"\"\n    cursor = self._connection.cursor()\n    if self._debug or debug:\n        await self.create_query_plan_markdown(operation, cursor, parameters)\n    await run_sync_in_worker_thread(cursor.executemany, operation, parameters)\n    self.logger.info(f\"Executed {len(parameters)} operations off {operation!r}.\")\n    return cursor\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_all","title":"<code>fetch_all</code>  <code>async</code>","text":"<p>Fetch all results from the database.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>A list of tuples representing the results.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_all(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_all(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Fetch all results from the database.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        A list of tuples representing the results.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n            result = conn.fetch_all(\"SELECT * FROM test_table\")\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        result = await run_sync_in_worker_thread(cursor.fetchall)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_arrow","title":"<code>fetch_arrow</code>  <code>async</code>","text":"<p>Fetch all results of the query from the database as an Arrow table.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <p>Returns:</p> Type Description <code>Any</code> <p>An Arrow table.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_arrow(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_arrow(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n) -&gt; Any:\n    \"\"\"\n    Fetch all results of the query from the database as an Arrow table.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        An Arrow table.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n            result = conn.fetch_arrow(\"SELECT * FROM test_table\")\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        result = await run_sync_in_worker_thread(cursor.arrow)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_df","title":"<code>fetch_df</code>  <code>async</code>","text":"<p>Fetch all results of the query from the database as a dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas dataframe.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_df(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_df(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n    date_as_object: bool = False,\n) -&gt; pandas.DataFrame:\n    \"\"\"\n    Fetch all results of the query from the database as a dataframe.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        A pandas dataframe.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n            result = conn.fetch_df(\"SELECT * FROM test_table\")\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(\n            cursor.execute, operation, parameters, date_as_object\n        )\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        result = await run_sync_in_worker_thread(cursor.df)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_many","title":"<code>fetch_many</code>  <code>async</code>","text":"<p>Fetch multiple results from the database.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <code>size</code> <code>Optional[int]</code> <p>The number of rows to fetch.</p> <code>1</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>A list of tuples representing the results.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute_many(\n        \"INSERT INTO test_table VALUES (?, ?)\",\n        parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n    )\n    result = conn.fetch_many(\"SELECT * FROM test_table\", size=2)\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_many(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n    size: Optional[int] = 1,\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Fetch multiple results from the database.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n        size: The number of rows to fetch.\n\n    Returns:\n        A list of tuples representing the results.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute_many(\n                \"INSERT INTO test_table VALUES (?, ?)\",\n                parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n            )\n            result = conn.fetch_many(\"SELECT * FROM test_table\", size=2)\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n        size = size\n        self.logger.debug(f\"Preparing to fetch {size} rows.\")\n        result = await run_sync_in_worker_thread(cursor.fetchmany, size=size)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_numpy","title":"<code>fetch_numpy</code>  <code>async</code>","text":"<p>Fetch all results of the query from the database as a numpy array. Args:     operation: The SQL operation to execute.     parameters: The parameters to pass to the operation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary representing a numpy array.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_numpy(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_numpy(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n) -&gt; dict:\n    \"\"\"\n    Fetch all results of the query from the database as a numpy array.\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        A dictionary representing a numpy array.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n            result = conn.fetch_numpy(\"SELECT * FROM test_table\")\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n        self.logger.debug(\"Preparing to fetch all rows.\")\n        result = await run_sync_in_worker_thread(cursor.fetchnumpy)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.fetch_one","title":"<code>fetch_one</code>  <code>async</code>","text":"<p>Fetch a single result from the database.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>parameters</code> <code>Optional[Dict[str, Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <p>Returns:</p> Type Description <code>Tuple[Any]</code> <p>A tuple representing the result.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_one(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def fetch_one(\n    self,\n    operation: str,\n    parameters: Optional[Dict[str, Any]] = [],\n) -&gt; Tuple[Any]:\n    \"\"\"\n    Fetch a single result from the database.\n\n    Args:\n        operation: The SQL operation to execute.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        A tuple representing the result.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n            conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n            result = conn.fetch_one(\"SELECT * FROM test_table\")\n            print(result)\n        ```\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        await run_sync_in_worker_thread(cursor.execute, operation, parameters)\n        self.logger.debug(\"Preparing to fetch a row.\")\n        result = await run_sync_in_worker_thread(cursor.fetchone)\n        return result\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.from_arrow","title":"<code>from_arrow</code>  <code>async</code>","text":"<p>Create a table from an Arrow object.</p> <p>Parameters:</p> Name Type Description Default <code>arrow_object</code> <code>Table</code> <p>The Arrow object.</p> required Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def from_arrow(\n    self, arrow_object: pa.Table, table_name: Optional[str] = None\n) -&gt; DuckDBPyRelation:\n    \"\"\"\n    Create a table from an Arrow object.\n\n    Args:\n        arrow_object: The Arrow object.\n    \"\"\"\n    cursor = self._connection.cursor()\n    table = await run_sync_in_worker_thread(cursor.from_arrow, arrow_object)\n    if table_name:\n        await run_sync_in_worker_thread(cursor.register, table_name, table)\n    return cursor\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.from_csv_auto","title":"<code>from_csv_auto</code>  <code>async</code>","text":"<p>Create a table from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the CSV file.</p> required Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def from_csv_auto(\n    self,\n    file_name: str,\n) -&gt; DuckDBPyRelation:\n    \"\"\"\n    Create a table from a CSV file.\n\n    Args:\n        file_name: The name of the CSV file.\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        return await run_sync_in_worker_thread(cursor.from_csv_auto, file_name)\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.from_df","title":"<code>from_df</code>  <code>async</code>","text":"<p>Create a table from a Pandas DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The Pandas DataFrame.</p> required <code>table_name</code> <code>Optional[str]</code> <p>The name of the table.</p> <code>None</code> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def from_df(\n    self,\n    df: pandas.DataFrame,\n    table_name: Optional[str] = None,\n) -&gt; DuckDBPyRelation:\n    \"\"\"\n    Create a table from a Pandas DataFrame.\n\n    Args:\n        df: The Pandas DataFrame.\n        table_name: The name of the table.\n    \"\"\"\n    cursor = self._connection.cursor()\n    table = await run_sync_in_worker_thread(cursor.from_df, df)\n    if table_name:\n        await run_sync_in_worker_thread(cursor.register, table_name, table)\n    return cursor\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.from_parquet","title":"<code>from_parquet</code>  <code>async</code>","text":"<p>Create a table from a Parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the Parquet file.</p> required Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def from_parquet(\n    self,\n    file_name: str,\n) -&gt; DuckDBPyRelation:\n    \"\"\"\n    Create a table from a Parquet file.\n\n    Args:\n        file_name: The name of the Parquet file.\n    \"\"\"\n    with self._connection.cursor() as cursor:\n        return await run_sync_in_worker_thread(cursor.from_parquet, file_name)\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.get_connection","title":"<code>get_connection</code>","text":"<p>Returns a  DuckDB connection, if <code>mother_ducktoken</code> is found in enviroment or config, it will be passed in the connection.</p> <p>Parameters:</p> Name Type Description Default <code>read_only</code> <code>Optional[bool]</code> <p>Whether the connection should be read-only.</p> <code>None</code> <code>config</code> <code>Optional[dict]</code> <p>Configuration to be used when creating connection.</p> <code>None</code> <p>Returns:</p> Type Description <code>DuckDBPyConnection</code> <p>A <code>DuckDBPyConnection</code> object.</p> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nduckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\nwith duckdb_connector as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING);\")\n    ...\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>def get_connection(\n    self, read_only: Optional[bool] = None, config: Optional[dict] = None\n) -&gt; DuckDBPyConnection:\n    \"\"\"\n    Returns a  DuckDB connection, if `mother_ducktoken` is found in enviroment\n    or config, it will be passed in the connection.\n\n    Args:\n        read_only: Whether the connection should be read-only.\n        config: Configuration to be used when creating connection.\n\n    Returns:\n        A `DuckDBPyConnection` object.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\n        with duckdb_connector as conn:\n            conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING);\")\n            ...\n        ```\n    \"\"\"\n    if self._connection is not None:\n        return self._connection\n\n    config = config or self.configuration or {}\n    read_only = read_only or self.read_only\n\n    if os.environ.get(\"motherduck_token\") and \"motherduck_token\" not in config:\n        config[\"motherduck_token\"] = os.environ.get(\"motherduck_token\")\n\n    connection = duckdb.connect(\n        database=self.database,\n        read_only=read_only,\n        config=config,\n    )\n\n    self._connection = connection\n    self.logger.info(f\"Started a new connection to {self.database}.\")\n    return connection\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.remove_function","title":"<code>remove_function</code>","text":"<p>Remove a function from the database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>string representing the unique name of the UDF within the catalog.</p> required Source code in <code>prefect_duckdb/database.py</code> <pre><code>def remove_function(self, name: str) -&gt; None:\n    \"\"\"\n    Remove a function from the database.\n\n    Args:\n        name: string representing the unique name of the UDF within the catalog.\n    \"\"\"\n    self._connection.remove_function(name)\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.set_debug","title":"<code>set_debug</code>","text":"<p>Set the debug mode of the connector.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Whether to enable debug mode.</p> required Source code in <code>prefect_duckdb/database.py</code> <pre><code>def set_debug(self, debug: bool) -&gt; None:\n    \"\"\"\n    Set the debug mode of the connector.\n\n    Args:\n        debug: Whether to enable debug mode.\n    \"\"\"\n    self._debug = debug\n    self.logger.info(f\"Set debug mode to {debug}.\")\n</code></pre>"},{"location":"connector/#prefect_duckdb.database.DuckDBConnector.sql","title":"<code>sql</code>  <code>async</code>","text":"<p>Execute the given SQL query, optionally using prepared statements with parameters set.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>The SQL operation to execute.</p> required <code>debug</code> <code>Optional[bool]</code> <p>Whether to run the operation in debug mode.    Sends the query plan to the logger.</p> <code>False</code> <p>Examples:</p> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.sql(\n        \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n    )\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@sync_compatible\nasync def sql(\n    self,\n    operation: str,\n    debug: Optional[bool] = False,\n) -&gt; DuckDBPyRelation:\n    \"\"\"\n    Execute the given SQL query, optionally using prepared statements\n    with parameters set.\n\n    Args:\n        operation: The SQL operation to execute.\n        debug: Whether to run the operation in debug mode.\n               Sends the query plan to the logger.\n\n    Examples:\n        ```python\n        from prefect_duckdb.database import DuckDBConnector\n\n        with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n            conn.sql(\n                \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n            )\n        ```\n    \"\"\"\n    self.get_connection()\n    cursor = self._connection.cursor()\n    if self._debug or debug:\n        await self.create_query_plan_markdown(operation=operation, cursor=cursor)\n    cursor = await run_sync_in_worker_thread(cursor.sql, operation)\n    self.logger.info(f\"Executed the operation, {operation!r}.\")\n    return cursor\n</code></pre>"},{"location":"connector/#prefect_duckdb.database-functions","title":"Functions","text":""},{"location":"connector/#prefect_duckdb.database.duckdb_query","title":"<code>duckdb_query</code>","text":"<p>Execute a query against a DuckDB database.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The SQL query to execute.</p> required <code>duckdb_connector</code> <code>DuckDBConnector</code> <p>The DuckDBConnector block to use.</p> required <code>parameters</code> <code>Optional[Iterable[Any]]</code> <p>The parameters to pass to the operation.</p> <code>[]</code> <p>Returns:</p> Type Description <code>List[Tuple[Any]]</code> <p>A list of tuples representing the results.</p> <p>Examples:</p> <pre><code>from prefect import Flow\nfrom prefect_duckdb.database import DuckDBConnector, duckdb_query\n\n@flow\ndef duckdb_query_flow():\n    duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\n    result = duckdb_query(\"SELECT * FROM test_table\", duckdb_connector)\n    print(result)\n\nduckdb_query_flow()\n</code></pre> Source code in <code>prefect_duckdb/database.py</code> <pre><code>@task\ndef duckdb_query(\n    query: str,\n    duckdb_connector: DuckDBConnector,\n    parameters: Optional[Iterable[Any]] = [],\n    debug: Optional[bool] = False,\n) -&gt; List[Tuple[Any]]:\n    \"\"\"\n    Execute a query against a DuckDB database.\n\n    Args:\n        query: The SQL query to execute.\n        duckdb_connector: The DuckDBConnector block to use.\n        parameters: The parameters to pass to the operation.\n\n    Returns:\n        A list of tuples representing the results.\n\n    Examples:\n        ```python\n        from prefect import Flow\n        from prefect_duckdb.database import DuckDBConnector, duckdb_query\n\n        @flow\n        def duckdb_query_flow():\n            duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\n            result = duckdb_query(\"SELECT * FROM test_table\", duckdb_connector)\n            print(result)\n\n        duckdb_query_flow()\n        ```\n\n    \"\"\"\n    result = duckdb_connector.execute(query, parameters, debug=debug)\n    return result\n</code></pre>"},{"location":"examples_catalog/","title":"Examples Catalog","text":"<p>Below is a list of examples for <code>prefect-duckdb</code>.</p>"},{"location":"examples_catalog/#database-module","title":"Database Module","text":"<p><pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_df(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute_many(\n        \"INSERT INTO test_table VALUES (?, ?)\",\n        parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n    )\n    result = conn.fetch_many(\"SELECT * FROM test_table\", size=2)\n    print(result)\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_arrow(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_one(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> <pre><code>    from prefect_duckdb.database import DuckDBConnector\n\n    with DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n        conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n        conn.execute_many(\n            \"INSERT INTO test_table VALUES (?, ?)\",\n            parameters=[[1, \"one\"], [2, \"two\"], [3, \"three\"]]\n        )\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_all(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING)\")\n    conn.execute(\"INSERT INTO test_table VALUES (1, 'one')\")\n    result = conn.fetch_numpy(\"SELECT * FROM test_table\")\n    print(result)\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.sql(\n        \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n    )\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nduckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\nwith duckdb_connector as conn:\n    conn.execute(\"CREATE TABLE test_table (i INTEGER, j STRING);\")\n    ...\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\nfrom prefect_aws import AwsCredentials\n\naws_credentials_block = AwsCredentials.load(\"BLOCK_NAME\")\nconnector = DuckDBConnector().load(\"BLOCK_NAME\")\nconnector.get_connection()\nconnector.create_secret(\n    name=\"test_secret\",\n    secret_type=\"S3\",\n    key_id=aws_credentials_block.access_key,\n    secret=aws_credentials_block.secret_access_key,\n    region=aws_credentials_block.region_name\n)\nconnector.execute(\"SELECT count(*) FROM 's3://&lt;bucket&gt;/&lt;file&gt;';\")\n</code></pre> <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE test_table (i INTEGER, j STRING)\"\n    )\n</code></pre> <pre><code>from prefect import Flow\nfrom prefect_duckdb.database import DuckDBConnector, duckdb_query\n\n@flow\ndef duckdb_query_flow():\n    duckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\")\n\n    result = duckdb_query(\"SELECT * FROM test_table\", duckdb_connector)\n    print(result)\n\nduckdb_query_flow()\n</code></pre> Load stored DuckDB connector as a context manager: <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nduckdb_connector = DuckDBConnector.load(\"BLOCK_NAME\"):\n</code></pre></p> <p>Insert data into database and fetch results. <pre><code>from prefect_duckdb.database import DuckDBConnector\n\nwith DuckDBConnector.load(\"BLOCK_NAME\") as conn:\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS customers (name varchar, address varchar);\"\n    )\n    conn.execute_many(\n        \"INSERT INTO customers (name, address) VALUES (%(name)s, %(address)s);\",\n        parameters=[\n            {\"name\": \"Ford\", \"address\": \"Highway 42\"},\n            {\"name\": \"Unknown\", \"address\": \"Space\"},\n            {\"name\": \"Me\", \"address\": \"Myway 88\"},\n        ],\n    )\n    results = conn.fetch_all(\n        \"SELECT * FROM customers WHERE address = %(address)s\",\n        parameters={\"address\": \"Space\"}\n    )\n    print(results)\n</code></pre></p>"}]}